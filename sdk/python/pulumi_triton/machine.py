# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import pulumi
import pulumi.runtime

class Machine(pulumi.CustomResource):
    def __init__(__self__, __name__, __opts__=None, administrator_pw=None, affinities=None, cloud_config=None, cns=None, deletion_protection_enabled=None, firewall_enabled=None, image=None, locality=None, metadata=None, name=None, networks=None, nics=None, package=None, root_authorized_keys=None, tags=None, user_data=None, user_script=None):
        """Create a Machine resource with the given unique name, props, and options."""
        if not __name__:
            raise TypeError('Missing resource name argument (for URN creation)')
        if not isinstance(__name__, basestring):
            raise TypeError('Expected resource name to be a string')
        if __opts__ and not isinstance(__opts__, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')

        __props__ = dict()

        if administrator_pw and not isinstance(administrator_pw, basestring):
            raise TypeError('Expected property administrator_pw to be a basestring')
        __self__.administrator_pw = administrator_pw
        """
        Administrator's initial password (Windows only)
        """
        __props__['administratorPw'] = administrator_pw

        if affinities and not isinstance(affinities, list):
            raise TypeError('Expected property affinities to be a list')
        __self__.affinities = affinities
        """
        Label based affinity rules for assisting instance placement
        """
        __props__['affinities'] = affinities

        if cloud_config and not isinstance(cloud_config, basestring):
            raise TypeError('Expected property cloud_config to be a basestring')
        __self__.cloud_config = cloud_config
        """
        copied to machine on boot
        """
        __props__['cloudConfig'] = cloud_config

        if cns and not isinstance(cns, dict):
            raise TypeError('Expected property cns to be a dict')
        __self__.cns = cns
        """
        Container Name Service
        """
        __props__['cns'] = cns

        if deletion_protection_enabled and not isinstance(deletion_protection_enabled, bool):
            raise TypeError('Expected property deletion_protection_enabled to be a bool')
        __self__.deletion_protection_enabled = deletion_protection_enabled
        """
        Whether to enable deletion protection for this machine
        """
        __props__['deletionProtectionEnabled'] = deletion_protection_enabled

        if firewall_enabled and not isinstance(firewall_enabled, bool):
            raise TypeError('Expected property firewall_enabled to be a bool')
        __self__.firewall_enabled = firewall_enabled
        """
        Whether to enable the firewall for this machine
        """
        __props__['firewallEnabled'] = firewall_enabled

        if not image:
            raise TypeError('Missing required property image')
        elif not isinstance(image, basestring):
            raise TypeError('Expected property image to be a basestring')
        __self__.image = image
        """
        UUID of the image
        """
        __props__['image'] = image

        if locality and not isinstance(locality, dict):
            raise TypeError('Expected property locality to be a dict')
        __self__.locality = locality
        """
        UUID based locality hints for assisting placement behavior
        """
        __props__['locality'] = locality

        if metadata and not isinstance(metadata, dict):
            raise TypeError('Expected property metadata to be a dict')
        __self__.metadata = metadata
        """
        Machine metadata
        """
        __props__['metadata'] = metadata

        if name and not isinstance(name, basestring):
            raise TypeError('Expected property name to be a basestring')
        __self__.name = name
        """
        Friendly name for machine
        """
        __props__['name'] = name

        if networks and not isinstance(networks, list):
            raise TypeError('Expected property networks to be a list')
        __self__.networks = networks
        """
        Desired network IDs
        """
        __props__['networks'] = networks

        if nics and not isinstance(nics, list):
            raise TypeError('Expected property nics to be a list')
        __self__.nics = nics
        """
        Network interface
        """
        __props__['nics'] = nics

        if not package:
            raise TypeError('Missing required property package')
        elif not isinstance(package, basestring):
            raise TypeError('Expected property package to be a basestring')
        __self__.package = package
        """
        The package for use for provisioning
        """
        __props__['package'] = package

        if root_authorized_keys and not isinstance(root_authorized_keys, basestring):
            raise TypeError('Expected property root_authorized_keys to be a basestring')
        __self__.root_authorized_keys = root_authorized_keys
        """
        Authorized keys for the root user on this machine
        """
        __props__['rootAuthorizedKeys'] = root_authorized_keys

        if tags and not isinstance(tags, dict):
            raise TypeError('Expected property tags to be a dict')
        __self__.tags = tags
        """
        Machine tags
        """
        __props__['tags'] = tags

        if user_data and not isinstance(user_data, basestring):
            raise TypeError('Expected property user_data to be a basestring')
        __self__.user_data = user_data
        """
        Data copied to machine on boot
        """
        __props__['userData'] = user_data

        if user_script and not isinstance(user_script, basestring):
            raise TypeError('Expected property user_script to be a basestring')
        __self__.user_script = user_script
        """
        User script to run on boot (every boot on SmartMachines)
        """
        __props__['userScript'] = user_script

        __self__.compute_node = pulumi.runtime.UNKNOWN
        """
        UUID of the server on which the instance is located
        """
        __self__.created = pulumi.runtime.UNKNOWN
        """
        When the machine was created
        """
        __self__.dataset = pulumi.runtime.UNKNOWN
        """
        Dataset URN with which the machine was provisioned
        """
        __self__.disk = pulumi.runtime.UNKNOWN
        """
        Amount of disk allocated to the machine (in Gb)
        """
        __self__.domain_names = pulumi.runtime.UNKNOWN
        """
        List of domain names from Triton CNS
        """
        __self__.ips = pulumi.runtime.UNKNOWN
        """
        IP addresses assigned to the machine
        """
        __self__.memory = pulumi.runtime.UNKNOWN
        """
        Amount of memory allocated to the machine (in Mb)
        """
        __self__.primaryip = pulumi.runtime.UNKNOWN
        """
        Primary (public) IP address for the machine
        """
        __self__.type = pulumi.runtime.UNKNOWN
        """
        Machine type (smartmachine or virtualmachine)
        """
        __self__.updated = pulumi.runtime.UNKNOWN
        """
        When the machine was updated
        """

        super(Machine, __self__).__init__(
            'triton:index/machine:Machine',
            __name__,
            __props__,
            __opts__)

    def set_outputs(self, outs):
        if 'administratorPw' in outs:
            self.administrator_pw = outs['administratorPw']
        if 'affinities' in outs:
            self.affinities = outs['affinities']
        if 'cloudConfig' in outs:
            self.cloud_config = outs['cloudConfig']
        if 'cns' in outs:
            self.cns = outs['cns']
        if 'computeNode' in outs:
            self.compute_node = outs['computeNode']
        if 'created' in outs:
            self.created = outs['created']
        if 'dataset' in outs:
            self.dataset = outs['dataset']
        if 'deletionProtectionEnabled' in outs:
            self.deletion_protection_enabled = outs['deletionProtectionEnabled']
        if 'disk' in outs:
            self.disk = outs['disk']
        if 'domainNames' in outs:
            self.domain_names = outs['domainNames']
        if 'firewallEnabled' in outs:
            self.firewall_enabled = outs['firewallEnabled']
        if 'image' in outs:
            self.image = outs['image']
        if 'ips' in outs:
            self.ips = outs['ips']
        if 'locality' in outs:
            self.locality = outs['locality']
        if 'memory' in outs:
            self.memory = outs['memory']
        if 'metadata' in outs:
            self.metadata = outs['metadata']
        if 'name' in outs:
            self.name = outs['name']
        if 'networks' in outs:
            self.networks = outs['networks']
        if 'nics' in outs:
            self.nics = outs['nics']
        if 'package' in outs:
            self.package = outs['package']
        if 'primaryip' in outs:
            self.primaryip = outs['primaryip']
        if 'rootAuthorizedKeys' in outs:
            self.root_authorized_keys = outs['rootAuthorizedKeys']
        if 'tags' in outs:
            self.tags = outs['tags']
        if 'type' in outs:
            self.type = outs['type']
        if 'updated' in outs:
            self.updated = outs['updated']
        if 'userData' in outs:
            self.user_data = outs['userData']
        if 'userScript' in outs:
            self.user_script = outs['userScript']
